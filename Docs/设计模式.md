# 设计模式

## 单例

在应用这个模式时，单例对象的类必须保证`只有一个实例`存在。许多时候整个系统只需要拥有一个全局对象，这样有利于协调系统整体的行为。比如某个服务器程序中个，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。

<!--more-->

实现单例的思路是: 一个类能返回对象的一个引用(`永远是同一个`)和一个获得该实例的方法(`必须是静态方法，通常使用getInstance这个名称`);当我们调用这个方法时，如果类持有的引用不为空就返回这个引用。如果类保持的引用为空，则创建该类的实例，并将实例的引用赋予该类并将实例的引用赋予该类保持的引用。`同时我们还将该类的构造函数定义为私有方法`，这样其他的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态法官法来得到该类的唯一实例。

单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。  

单例模式是一种常见的设计模式，在计算机系统中，`线程池`、`缓存`、`日志对象`、`对话框`、`打印机`、`数据库操作`、`显卡驱动`常被设计成单例。  

3个特点：  

1. 只能有一个实例
2. 必须自行创建这个实例  
3. 必须給其他对象提供这一个实例  

```
class Comm_Db
{
	private static $_instance;
	private static $_connectSource;
	
	private $_dbConfig = [
		'host' => 'XXX',
		'port' => 'XXX',
		'user' => 'XXX',
		'password' => 'XXX',
		'database' => 'XXX',
	];
	
	private function __constract()
	{
	
	}
	
	private function __clone()
	{
	
	}
	
	public static function getInstance()
	{
		if (!self::$_instance)
		{
			self::$_instance = new self();
		}
		
		return self::$_instance;
	}
	
	public function connect()
	{
		if (!self::$_connectSource)
		{
			self::$_connectSource = mysqli_connect(
				$this->_dbConfig['host'],
                $this->_dbConfig['user'],
                $this->_dbConfig['password'],
                $this->_dbConfig['database'],
                $this->_dbConfig['port']
			);
			
			if (!self::$_connectSource)
			{
				die("mysql connect error " . mysqli_error($this->_dbConfig['database']));
			}
			
			mysqli_select_db(self::$_connectSource, $this->_dbConfig['database']);
          	mysqli_query(self::$_connectSource, "set names UTF8 ");
		}
		
		return self::$_connectSource;
	}
}
```
## 适配器模式

### 意图
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**Target适配目标** : 该角色定义把其他类转换为何种接口，也就是期望的接口  
**Adaptee被适配者** : 就是需要被适配的接口。  
**Adapter适配器** : 其他的两个角色都是已经存在的角色，而适配器的角色是需要重新建立的，它用来对Adaptee与Target接口进行适配。

![avatar](https://segmentfault.com/img/bVFFeR?w=629&h=326)

### 场景
如果代码中有关联Mysql、mysqli、pdo、sqlite、postgresql等操作，而你需要根据情况切换数据库时，可以使用适配器模式统一接口，这样代码除了数据库配置之外，就不需要做其他的更改。 缓存亦然。

### 代码实例
```
<?php
/**
 * Created by PhpStorm.
 * User: pengcheng8
 * Date: 17/9/11
 * Time: 下午2:39
 * DESC: 适配器模式演示代码。
 *          Target适配目标: IDataBase接口
 *          Adaptee被适配者: mysql和mysqli、postgresql的数据库操作函数
 *          Adapter适配器: mysql类和mysqli类、postgresql类
 */

/*
 * Interface IDatabase 适配目标，规定的接口将被适配对象实现
 * 约定好统一的api行为
 * */
interface IDatabase
{
    //定义数据库连接方法
    public function connect($host, $username, $password, $database);
    //定义数据库查询方法
    public function query($sql);
    //关闭数据库
    public function close();
}

/*
 * Class Mysql 适配器
 * **/
class Mysql implements IDatabase
{
    protected $connect;

    public function connect($host, $username, $password, $database)
    {
        // TODO: Implement connect() method.
        $connect = mysqli_connect($host, $username, $password, $database);
        mysqli_select_db($database, $connect);
        $this->connect = $connect;
    }

    public function query($sql)
    {
        // TODO: Implement query() method.
        return mysqli_query($this->connect,$sql);
    }

    public function close()
    {
        // TODO: Implement close() method.
        mysqli_close($this->connect);
    }
}

class Postgresql implements IDatabase
{
    protected $connect;

    public function connect($host, $username, $password, $database)
    {
        // TODO: Implement connect() method.
        $this->connect = pg_connect(
            "host=$host 
                              dbname=$database
                              user=$username
                              password=$password
                              ");
    }

    public function query($sql)
    {
        // TODO: Implement query() method.
        return pg_query($this->connect, $sql);
    }

    public function close()
    {
        // TODO: Implement close() method.
        pg_close();
    }
}

/*
 * 演示使用实例
 * 以mysqli为例
 * 因为都是同一个接口，所以可以随意切换
 * **/

$host = 'localhost';
$username = 'root';
$password = '123456';
$database = 'test';

$client = new mysqli();
$client->connect($host, $username, $password, $database);
$result = $client->query("SELECT * FROM DB");

while ($rows = mysqli_fetch_array($result))
{
    var_dump($rows);
}

```

## 迭代器(Iterator)

迭代器模式(Iterator)，又叫游标(Cursor)模式。提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。

当你需要访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式。

### 适用场景

1. 访问一个聚合对象的内容而无需暴露它的内部表示
2. 支持对聚合对象的多种遍历
3. 为遍历不同的聚合结构提供一个统一的接口

![avatar](https://segmentfault.com/img/bVFO1y?w=500&h=299)

### 角色

1. Iterator(迭代器): 迭代器定义访问和遍历元素的接口
2. Concretelterator(具体迭代器): 具体迭代器实现迭代器接口，对该聚合遍历时跟踪当前位置
3. Aggregate(聚合): 聚合定义创建相应迭代器对象的接口
4. ConcreateAggregate(具体聚合): 具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。

```
<?php
/**
 * Created by PhpStorm.
 * User: pengcheng8
 * Date: 17/9/11
 * Time: 下午5:53
 * DESC: PHP 自带了迭代器
 */

class IteratorClient implements Iterator
{
    private $position = 0;
    private $array = [];

    public function __construct($array)
    {
        $this->array = $array;
        $this->position = 0;
    }

    function rewind()
    {
        $this->position = 0;
    }

    function current()
    {
        // TODO: Implement current() method.
        return $this->array[$this->position];
    }

    function key()
    {
        return $this->position;
    }

    function next()
    {
        ++$this->position;
    }

    function valid()
    {
        // TODO: Implement valid() method.
        return isset($this->array[$this->position]);
    }
}

class ConcreteAggregate implements IteratorAggregate
{
    public $property;

    /*
     * 添加属性
     * **/
    public function addProperty($property)
    {
        $this->property[] = $property;
    }

    public function getIterator()
    {
        // TODO: Implement getIterator() method.
        return new IteratorClient($this->property);
    }
}

class Client
{
    public static function test()
    {
        //创建容器
        $concreteAggregate = new ConcreteAggregate();
        //添加属性
        $concreteAggregate->addProperty('属性1');
        //添加属性
        $concreteAggregate->addProperty('属性2');
        //给容器创建迭代器
        $iterator = $concreteAggregate->getIterator();
        //遍历
        while($iterator->valid())
        {
            $key = $iterator->key();
            $value = $iterator->current();
            echo '键:' . $key . '值: ' . $value . "<hr>";
            $iterator->next();
        }

    }
}

client::test();

```
